<!DOCTYPE html>
<head>
<title>HACKER_WEB</title>

</head>

<body bgcolor="black" >

<font size="5" color="green">
<marquee height="100%" width="100%"  direction="up">
<pre>

if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks[0] = group_info->small_block;
else {
for (i=0; i<nblocks; i++) {
gid_t *b;
b=(void*) get_free_page(GFP_USER);
if (!b)
goto out_undo_partial_alloc;
group_info->blocks[i] = b;
}

Chet 120.netmask 20.0.0.0
Hurellen 225 scoceid 0-20most
//LOOD SHOVEDELen svou local cocback)

///A packets 154 bytes 15120 (14.7 KiB)
RA errors dropped overruns frame o
Tx packets 154 bytes 15120 (14.7 KiB)
Tx errors dropped overruns 0 carrier 0 collisions
vnnel1; flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.72.1 netmask 255.255.255.0 broadcast 192.168.72.255 Inets fe80::250:56ff:fec0:1 prefixlén 64 scopeid 0x20<link>
//ether 00:50:56:00:00:01 txqueuelen 1000 (Ethernet)

RX packets bytes (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 0 (0.0 B)
TX errors dropped overruns carrier e collisions D
vmneta:
flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 172.16.248.1 netmask 255.255.255.0 broadcast 172.16.248.255
inet6 fe80::250:56ff: fece:8 prefixlen 64 scopeid 8×20<link>
ether 00:50:56:c0:00:08 txqueuelen 1000 (Ethernet)

RX-packets bytes 0 (0.0 B)
RX errors dropped overruns frame
TX packets 125 bytes 8 (0.08)
TX errors dropped overruns 0 carrier e collisions

wlan0: flags-4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
inet 192.168.0.5 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80:: 9984:e6c4:3b33:6636 prefixlen 64 scopeid 0x20<link>
ether 0c:96:e6:9f:41:11 txqueuelen 1000 (Ethernet)
RX packets 2396538 bytes 2600291913 (2.4 618)
RX errors e dropped overruns frame TX packets 1561672 bytes 187390460 (178.7 MiB)
8x609
TX errors dropped overruns carrier e collisions
.
.
.
.

struct group_info init_groups ( usage ATOMIC_INIT(2) };
struct group_info *groups_alloc(int gidsetsize){
struct group_info *group_info;
int nblocks;
int i;
nblocks (gidsetsize + NGROUPS_PER_BLOCK 1) / NGROUPS_PER_BLOCK;
/* Make sure we always allocate at least one indirect block pointer */
nblocks nblocks?: 1;
group_info kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GF
if (Igroup_info)
return NULL;
group_info->ngroups gidsetsize;
group_info->nblocks nblocks;
atomic_set(&group_info->usage, 1);
if (gidsetsize <= NGROUPS_SMALL)
group_info->blocks [0] group_info->small_block;
else {


</pre>
</marquee>
</font>

</body>
</html>